{"mappings":"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","sources":["src/constants.ts","src/utils.ts","src/game/entropy.ts","src/data/CoordinateSet.ts","src/game/getPossibleMoves.ts","src/game/play.ts","src/view/score.component.ts","src/view/render.ts","src/listeners/resize.ts","src/listeners/drag.ts","src/view/clearCanvas.ts","src/ai/aggressor.ts","src/ai/scaredycat.ts","src/ai/smartAggressor.ts","src/main.ts"],"sourcesContent":["export const SQUARE_BORDER = 1;\nexport const TICK_INTERVAL = 1;","import { Coords } from \"./types\"\n\nexport const coords = (_x: number, _y: number): Coords => ({ x: _x, y: _y })\nexport const addCoords = (a: Coords, b: Coords): Coords => ({\n  x: a.x + b.x,\n  y: a.y + b.y,\n})\nexport const subtractCoords = (a: Coords, b: Coords): Coords => ({\n  x: a.x - b.x,\n  y: a.y - b.y,\n})\n\nexport const iterate = (_x: number, _y: number, callback: (coords: Coords) => void) => {\n  for (let x = 0; x < _x; x++) {\n    for (let y = 0; y < _y; y++) {\n      callback({ x, y });\n    }\n  }\n\n}\n\nexport const fromTo = (start: number, end: number, callback: (num: number) => void) => {\n  for (let i = start; i <= end; i++) {\n    callback(i);\n  }\n}\n\nexport const pick = <T>(arr: T[]): T | undefined => {\n  if (arr.length === 0) {\n    return undefined;\n  }\n\n  const index = getRandomInt(arr.length - 1)\n\n  if (index === undefined) {\n    return undefined;\n  }\n\n  return arr[index];\n}\n\nexport const getRandomInt = (max: number) => Math.floor(Math.random() * max)","import { Player, State } from \"../types\";\nimport { getRandomInt } from \"../utils\";\n\nconst entropy = ( state: State) => {\n  if (state.settings.entropy === 0) {\n    return;\n  }\n  \n  // randomly kill one cell each turn\n  state.players.forEach(player => {\n    const numberOfCellsToKill = getRandomInt(state.settings.entropy);\n    if (numberOfCellsToKill >= player.cells.length / 100) {\n      return;\n    }\n\n    const numberOfCells = player.cells.length;\n    const randomCellIndex = getRandomInt(numberOfCells);\n    player.cells.splice(randomCellIndex, 1);\n  })\n}\n\nexport default entropy;","// uses an internal tree structure to simulate set-like behaviour\nexport default class CoordinateSet<T> {\n  tree: Record<string, Record<string, T>> = {}\n\n  add(x: number, y: number, val: T) {\n    this.tree[x] ||= {}\n    this.tree[x][y] = val;\n  }\n\n  remove(x: number, y: number) {\n    // if the coordinate doesn't exist, don't do anything\n    if (!this.tree[x] || !this.tree[y]) {\n      return;\n    }\n\n    // otherwise, delete it\n    delete this.tree[x][y];\n\n    // if the branch has no leaves, delete the branch, too\n    if (!Object.keys(this.tree[x]).length) {\n      delete this.tree[x]\n    }\n  }\n\n  get(x: number, y: number): T | undefined {\n    if (!this.has(x, y)) {\n      return undefined;\n    }\n\n    return this.tree[x][y];\n  }\n\n  has(x: number, y: number) {\n    const hasX = Object.prototype.hasOwnProperty.call(this.tree, \"\" + x);\n    if (!hasX) {\n      return false;\n    }\n    const hasY = Object.prototype.hasOwnProperty.call(this.tree[x], \"\" + y);\n    if (!hasY) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * \n   * @param x The x coordinate\n   * @param y The y coordinate\n   * @param callback Use this callback to set the new value. No-op if it returns undefined.\n   */\n  modify(x: number, y: number, callback: (val: T | undefined) => T | undefined) {\n    const oldVal = this.get(x, y);\n    const newVal = callback(oldVal);\n    if (newVal !== undefined) {\n      this.add(x, y, newVal)\n    }\n  }\n\n  toArray() {\n    type CoordinateArray = {x: number, y: number, val: T}[]\n    const arr: CoordinateArray = [];\n\n    Object.keys(this.tree).forEach((x) => {\n      Object.keys(this.tree[x]).forEach((y) => {\n        arr.push({x: +x, y: +y, val: this.tree[x][y]})\n      })\n    })\n    return arr;\n  }\n}","import { Player, PossibleMove, State } from \"../types\";\nimport CoordinateSet from \"../data/CoordinateSet\";\nimport { coords, fromTo } from \"../utils\";\n\nconst getPossibleMoves = (player: Player, state: State, occupiedCells: CoordinateSet<Player>): PossibleMove[] => {\n  // ADDRESSABLE CELLS STEP 1\n  // create a tree of all unique cells that are adjacent to any cell that this \n  // player owns, regardless of whether they're occupied.\n  const addressableTree = new CoordinateSet<boolean>();\n  player.cells.forEach(cell => {\n    fromTo(-1, 1, (x) => {\n      fromTo(-1, 1, (y) => {\n        addressableTree.add(cell.x + x, cell.y + y, true);\n      })\n    });\n  });\n\n  // ADDRESSABLE CELLS STEP 2\n  // second pass: player-occupied cells are not a possible move, so remove them\n  player.cells.forEach(cell => {\n    addressableTree.remove(cell.x, cell.y);\n  })\n\n  const addressableArr = addressableTree.toArray().filter(c => c.val === true);\n\n  // DECISIONS\n  // other-occupied cells can be attacked\n  const decisionTree = new CoordinateSet<PossibleMove>();\n  addressableArr.forEach(({x, y}) => {\n    if (occupiedCells.has(x, y)) {\n      const player = occupiedCells.get(x, y);\n\n      // handling weird edge case for Typescript's sake\n      if (!player) return;\n\n      decisionTree.add(x, y, {\n        type: \"ATTACK\",\n        targetCell: {\n          coords: coords(x,y),\n          owner: player\n        }\n      })\n    } else {\n      decisionTree.add(x, y, {\n        type: \"COLONIZE\",\n        targetCell: {\n          coords: coords(x,y)\n        }\n      })\n    }\n  });\n\n  // ADD POSSIBILITY OF PASSING THE TURN\n  const possibleMoves = decisionTree.toArray().map(c => c.val);\n  possibleMoves.push({\n    type: \"PASS\"\n  });\n\n  return possibleMoves;\n}\n\nexport default getPossibleMoves;","import { Player, State } from \"../types\";\nimport entropy from \"./entropy\";\nimport aggressor from \"../ai/aggressor\";\nimport getPossibleMoves from \"./getPossibleMoves\";\nimport CoordinateSet from \"../data/CoordinateSet\";\n\nconst play = (state: State) => {\n    // Make a 'map' of all occupied cells\n    const occupiedCells = new CoordinateSet<Player>();\n    state.players.forEach(player => {\n      player.cells.forEach(cell => {\n        occupiedCells.add(cell.x, cell.y, player);\n      })\n    })\n    \n  state.players.forEach(player => {\n    // get all possible moves\n    const possibleMoves = getPossibleMoves(player, state, occupiedCells);\n\n    // let the player pick a move\n    const move = player.ai({player, state, possibleMoves, occupiedCells});\n\n    // process the move\n    switch(move.type) {\n      case \"ATTACK\":\n        // player.cells.push(move.targetCell.coords);\n        move.targetCell.owner.cells = move.targetCell.owner.cells.filter(cell => cell.x !== move.targetCell.coords.x || cell.y !== move.targetCell.coords.y)\n        player.cells.push({\n          x: move.targetCell.coords.x,\n          y: move.targetCell.coords.y\n        })\n        break;\n      case \"COLONIZE\":\n        player.cells.push(move.targetCell.coords);\n        break;\n      case \"PASS\":\n        break;\n      default:\n        break;\n    }\n  });\n  \n  entropy(state);\n}\n\nexport default play;","import { Coords, Player } from \"../types\";\nimport { Component } from \"./component.type\";\n\nconst ORIGIN: Coords = {\n  x: 20,\n  y: 20\n}\nconst LINE_HEIGHT = 20;\n\ntype Props = {\n  players: Player[]\n}\nconst ScoreComponent: Component<Props> = ({players, canvas}) => {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return;\n\n  // The name\n  ctx.font = \"20px Georgia\"\n  players.forEach((player, i) => {\n    ctx.fillStyle = player.color;\n    const x = ORIGIN.x;\n    const y = ORIGIN.y * (i + 1);\n    ctx?.fillText(`${player.cells.length} - ${player.name}`, x, y)\n  })\n}\n\nexport default ScoreComponent;","import { Camera, Coords, State } from \"../types\";\nimport { Component } from \"./component.type\";\nimport { SQUARE_BORDER } from \"../constants\";\nimport {  subtractCoords } from \"../utils\";\nimport ScoreComponent from \"./score.component\";\n\nconst drawRect = (ctx: CanvasRenderingContext2D, coords: Coords, color: string, camera: Camera) => {\n  const { x, y } = subtractCoords(coords, camera.origin)\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  ctx.fillRect(x * camera.zoom, y * camera.zoom, (camera.zoom - SQUARE_BORDER), (camera.zoom - SQUARE_BORDER))\n}\n\nconst render: Component<{ state: State}> = ({state}) => {\n  const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    return;\n  }\n\n  // draw players\n  state.players.forEach(player => {\n    player.cells.forEach((coords) => {\n    \n      drawRect(ctx, coords, player.color, state.camera)\n    })\n  })\n\n  // add score\n\n  ScoreComponent({canvas, players: state.players});\n}\n\nexport default render;","const resize = () => {\n  const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n\n  if(!canvas) {\n    return;\n  }\n\n  const width = window.innerWidth;\n  const height = window.innerHeight;\n\n  canvas.setAttribute(\"height\", \"\" + height )\n  canvas.setAttribute(\"width\", \"\" + width )\n}\n\nexport default resize;","import { Coords, State } from \"../types\";\nimport { addCoords, subtractCoords } from \"../utils\";\n\nconst dragHoc = (state: State, onDrag: () => void) => {\n  let lastCameraOrigin: Coords; // need this because browsers send bad coords sometimes\n  let isDrawing = false;\n  let clickOrigin: Coords;\n  let cameraOrigin: Coords;\n  const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n\n  canvas.addEventListener('mousedown', function(evt) {\n    isDrawing = true;\n    clickOrigin = { x: evt.clientX, y: evt.clientY };\n    cameraOrigin = {...state.camera.origin}\n  })\n\n  canvas.addEventListener('mousemove', (evt) => {\n    if (!isDrawing) {\n      return;\n    }\n\n    const clickCoords: Coords = {\n      x: evt.clientX,\n      y: evt.clientY\n    }\n\n    const transposition: Coords = subtractCoords(clickCoords, clickOrigin);\n    lastCameraOrigin = state.camera.origin;\n    state.camera.origin = subtractCoords(cameraOrigin, transposition);\n\n    onDrag();\n  })\n\n  canvas.addEventListener('wheel', (evt) => {\n    const event = evt as unknown as WheelEvent;\n    \n    evt.preventDefault();\n    // const SCALER = 5;\n    // const diff = Math.round(event.deltaY / SCALER);\n    const diff = event.deltaY === 0 \n      ? 0 \n      : event.deltaY > 0\n        ? 1\n        : -1;\n\n      \n    state.camera.zoom = Math.min(Math.max(state.camera.zoom + diff, 3), 7);\n    // state.camera.origin.x += diff / 2;\n    // state.camera.origin.y += diff / 2;\n\n\n    onDrag()\n  })\n\n  canvas.addEventListener('mouseup', () => {\n    isDrawing = false;\n    if (lastCameraOrigin) {\n      state.camera.origin = lastCameraOrigin;\n    }\n  })\n}\n\nexport default dragHoc;","import { Component } from \"./component.type\";\n\nconst clearCanvas: Component = ({ canvas }) => {\n  const ctx = canvas.getContext('2d');\n  ctx?.clearRect(0,0,canvas.width, canvas.height);\n}\n\nexport default clearCanvas;","import { Ai, PossibleMove, MoveType } from \"../types\";\nimport { pick } from \"../utils\";\n\nconst PRIORITIES: Record<MoveType, number> = {\n  \"ATTACK\": 1000,\n  \"COLONIZE\": 500,\n  \"PASS\": 0\n}\n\nconst aggressor: Ai = ({possibleMoves}): PossibleMove => {\n  // choose a move based on some logic, and return it\n  let tentativeMove: PossibleMove | undefined;\n  \n  const aggressiveMoves = possibleMoves\n    .filter(pm => pm.type === \"ATTACK\" || pm.type === \"COLONIZE\")\n    .sort((a, b) => {\n      return PRIORITIES[b.type] - PRIORITIES[a.type];\n    })\n\n  // always pick aggressive moves\n  if (aggressiveMoves.length) {\n    tentativeMove = pick(aggressiveMoves);\n  } else {\n    tentativeMove = pick(possibleMoves)\n  }\n\n  if (!tentativeMove) {\n    tentativeMove = {\n      type: \"PASS\"\n    }\n  }\n\n  return tentativeMove;\n}\n\nexport default aggressor;","import { Ai, PossibleMove } from \"../types\";\nimport { pick } from \"../utils\";\n\nconst scaredycat: Ai = ({possibleMoves}): PossibleMove => {\n  // choose a move based on some logic, and return it\n  let tentativeMove: PossibleMove | undefined;\n  \n  tentativeMove = pick(possibleMoves.filter(pm => pm.type !== \"ATTACK\"));\n\n  if (!tentativeMove) {\n    tentativeMove = {\n      type: \"PASS\"\n    }\n  }\n\n  return tentativeMove;\n}\n\nexport default scaredycat;","import CoordinateSet from \"../data/CoordinateSet\";\nimport { Ai, Coords, MoveType, PossibleMove } from \"../types\";\nimport { pick } from \"../utils\";\n\nconst PRIORITIES: Record<MoveType, number> = {\n  \"ATTACK\": 1000,\n  \"COLONIZE\": 500,\n  \"PASS\": 0\n}\n\nclass GridBucket {\n  coordinateSet: CoordinateSet<number>;\n\n  constructor(private bucketSize: number) {\n    this.coordinateSet = new CoordinateSet();\n  }\n\n  increment(x: number, y: number) {\n    const bucketIndex = this.getBucketIndex({x, y});\n\n    this.coordinateSet.modify(bucketIndex.x, bucketIndex.y, (oldVal) => {\n      if (oldVal === undefined) {\n        return 0;\n      } else {\n        return oldVal + 1;\n      }\n    });\n  }\n\n  getHighest(): Coords | undefined {\n    const sortedCoords = this.coordinateSet.toArray().sort(({val: valA}, {val: valB}) => {\n      return valB - valA\n    });\n    \n    if (!sortedCoords.length) {\n      return undefined;\n    }\n\n    return sortedCoords[0];\n  }\n\n  getScoreOfBucket(bucketCoords: Coords) {\n    const {x, y} = this.getBucketIndex(bucketCoords);\n    return this.coordinateSet.get(x, y)\n  }\n\n  private getBucketIndex(coords: Coords): Coords {\n    const x = Math.floor(coords.x / this.bucketSize);\n    const y = Math.floor(coords.y / this.bucketSize);\n    return {x, y};\n  }\n}\n\nconst smartAggressor: Ai = ({player: self, possibleMoves, occupiedCells}): PossibleMove => {\n  // \"score\" 9x9 grids of cells by how many enemies they have.\n  // (9x9 is just illustrative, it could be a different size)\n  // then, colonize or atack a cell that's the closest to the center of the most clustered bucket\n  const BUCKET_SIZE = 12;\n  const bucket = new GridBucket(BUCKET_SIZE);\n  occupiedCells.toArray().forEach(({x, y, val: player}) => {\n    // don't score for self\n    if (player === self) {\n      return;\n    }\n\n    bucket.increment(x, y);\n  });\n  const bestCoord: Coords | undefined = bucket.getHighest();\n\n  let pickedMove: PossibleMove | undefined;\n\n  if (bestCoord) {\n    const sortedArr = possibleMoves.sort((a, b) => {\n      if(PRIORITIES[a.type] !== PRIORITIES[b.type]) {\n        return (PRIORITIES[b.type] - PRIORITIES[a.type]);\n      }\n\n      const aScore: number = a.type === \"PASS\"\n        ? 0\n        : (bucket.getScoreOfBucket(a.targetCell.coords) || 0)\n\n      const bScore: number = a.type === \"PASS\"\n        ? 0\n        : (bucket.getScoreOfBucket(a.targetCell.coords) || 0)\n\n      const score = bScore - aScore;\n      return score;\n    });\n\n    pickedMove = sortedArr[0];\n    console.log(\"PICKED MOVE\", pickedMove)\n  } else {\n    // there are no enemies, probably. Do anything.\n    pickedMove = pick(possibleMoves)\n  }\n\n  return pickedMove || { type: \"PASS\" }\n}\n\nexport default smartAggressor;","import \"./reset.css\"\n\nimport { State } from \"./types\";\nimport { TICK_INTERVAL } from \"./constants\";\nimport play from \"./game/play\";\nimport render from \"./view/render\";\nimport resize from \"./listeners/resize\";\nimport { coords } from \"./utils\";\nimport dragHoc from \"./listeners/drag\";\nimport clearCanvas from \"./view/clearCanvas\";\nimport aggressor from \"./ai/aggressor\";\nimport scaredycat from \"./ai/scaredycat\";\nimport smartAggressor from \"./ai/smartAggressor\";\n\nconst canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n\nconst state: State = {\n  players: [\n    {\n      name: \"Scaredy Cat\",\n      color: 'blue',\n      ai: scaredycat,\n      cells: [\n        coords(20, 20),\n      ],\n    },\n    {\n      name: \"Aggressor\",\n      color: 'red',\n      ai: aggressor,\n      cells: [\n        coords(15, 15),\n      ]\n    },\n    {\n      name: \"Aggressor 2.0 (WIP)\",\n      color: 'green',\n      ai: smartAggressor,\n      cells: [\n        coords(25, 25),\n      ]\n    }\n  ],\n  camera: {\n    origin: coords(-100,-100),\n    zoom: 5\n  },\n  settings: {\n    entropy: 0\n  }\n};\n\n// start game\nsetInterval(() => play(state), TICK_INTERVAL)\n\n// start animation\nconst doRender = () => {\n  clearCanvas({canvas});\n  render({state, canvas});\n  requestAnimationFrame(doRender);\n}\nrequestAnimationFrame(doRender)\n\n// listen for resizes\nwindow.addEventListener('resize', () => {\n  resize();\n  clearCanvas({canvas});\n})\nresize();\n\n// listener for dragging\ndragHoc(state, () => {\n  clearCanvas({canvas})\n});"],"names":["$491c08b17ce07690$export$5bf93b4680474bd","_x","_y","x","y","$491c08b17ce07690$export$ad19a5094122dc9b","a","b","$491c08b17ce07690$export$ed3047ae95eb9b2b","start","end","callback","i","$491c08b17ce07690$export$357523c63a2253b9","arr","length","index","$491c08b17ce07690$export$b141de964f0a90c1","undefined","max","Math","floor","random","$8d214408f19a9225$export$2e2bcd8739ae039","state","settings","entropy","players","forEach","player","cells","numberOfCells","randomCellIndex","splice","$dbd879a4e1d22e51$export$2e2bcd8739ae039","add","x5","y5","val","this","tree","remove","x1","y1","Object","keys","get","x2","y2","has","x3","y3","prototype","hasOwnProperty","call","modify","x4","y4","newVal","toArray","push","$2a3b91f3c920d10b$export$2e2bcd8739ae039","player1","occupiedCells","addressableTree","cell","addressableArr","filter","c","decisionTree","type","targetCell","coords","owner","possibleMoves","map","$74a106239bce058c$export$2e2bcd8739ae039","move","ai","$6eddd9d8fd198adc$var$ORIGIN","$6eddd9d8fd198adc$export$2e2bcd8739ae039","canvas","ctx","getContext","font","fillStyle","color","fillText","name","$92ba300e1b981fad$export$2e2bcd8739ae039","document","getElementById","camera","origin","strokeStyle","fillRect","zoom","$92ba300e1b981fad$var$drawRect","$15fd7dbc7d3d03f8$export$2e2bcd8739ae039","width","window","innerWidth","height","innerHeight","setAttribute","$d6299355fba89b70$export$2e2bcd8739ae039","onDrag","lastCameraOrigin","clickOrigin","cameraOrigin","isDrawing","addEventListener","evt","clientX","clientY","clickCoords","transposition","event","preventDefault","diff","deltaY","min","$0c3a382b741e81dd$export$2e2bcd8739ae039","clearRect","$2249b60c5077eea2$var$PRIORITIES","ATTACK","COLONIZE","PASS","$2249b60c5077eea2$export$2e2bcd8739ae039","tentativeMove","aggressiveMoves","pm","sort","$9ba632252bc9170e$export$2e2bcd8739ae039","$8540f255c7840a4b$var$PRIORITIES","$8540f255c7840a4b$var$GridBucket","bucketSize","coordinateSet","increment","bucketIndex","getBucketIndex","oldVal","getHighest","sortedCoords","valA","valB","getScoreOfBucket","bucketCoords","$8540f255c7840a4b$export$2e2bcd8739ae039","self","bucket","pickedMove","aScore","console","log","$5ba171b4a505aeb2$var$canvas","$5ba171b4a505aeb2$var$state","setInterval","$5ba171b4a505aeb2$var$doRender","requestAnimationFrame"],"version":3,"file":"index.2ebb5c11.js.map"}