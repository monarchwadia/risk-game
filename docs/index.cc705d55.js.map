{"mappings":"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","sources":["src/constants.ts","src/utils.ts","src/game/entropy.ts","src/data/CoordinateSet.ts","src/game/getPossibleMoves.ts","src/game/play.ts","src/view/render.ts","src/listeners/resize.ts","src/listeners/drag.ts","src/view/clearCanvas.ts","src/ai/aggressor.ts","src/ai/scaredycat.ts","src/main.ts"],"sourcesContent":["export const SQUARE_BORDER = 1;\nexport const TICK_INTERVAL = 1;","import { Coords } from \"./types\"\n\nexport const coords = (_x: number, _y: number): Coords => ({ x: _x, y: _y })\nexport const addCoords = (a: Coords, b: Coords): Coords => ({\n  x: a.x + b.x,\n  y: a.y + b.y,\n})\nexport const subtractCoords = (a: Coords, b: Coords): Coords => ({\n  x: a.x - b.x,\n  y: a.y - b.y,\n})\n\nexport const iterate = (_x: number, _y: number, callback: (coords: Coords) => void) => {\n  for (let x = 0; x < _x; x++) {\n    for (let y = 0; y < _y; y++) {\n      callback({ x, y });\n    }\n  }\n\n}\n\nexport const fromTo = (start: number, end: number, callback: (num: number) => void) => {\n  for (let i = start; i <= end; i++) {\n    callback(i);\n  }\n}\n\nexport const pick = <T>(arr: T[]): T | undefined => {\n  if (arr.length === 0) {\n    return undefined;\n  }\n\n  const index = getRandomInt(arr.length - 1)\n\n  if (index === undefined) {\n    return undefined;\n  }\n\n  return arr[index];\n}\n\nexport const getRandomInt = (max: number) => Math.floor(Math.random() * max)","import { Player, State } from \"../types\";\nimport { getRandomInt } from \"../utils\";\n\nconst entropy = ( state: State) => {\n  // randomly kill one cell each turn\n  state.players.forEach(player => {\n    const numberOfCellsToKill = getRandomInt(10);\n    if (numberOfCellsToKill >= player.cells.length / 100) {\n      return;\n    }\n\n    const numberOfCells = player.cells.length;\n    const randomCellIndex = getRandomInt(numberOfCells);\n    player.cells.splice(randomCellIndex, 1);\n  })\n}\n\nexport default entropy;","// uses an internal tree structure to simulate set-like behaviour\nexport default class CoordinateSet<T> {\n  tree: Record<string, Record<string, T>> = {}\n\n  add(x: number, y: number, val: T) {\n    this.tree[x] ||= {}\n    this.tree[x][y] = val;\n  }\n\n  remove(x: number, y: number) {\n    // if the coordinate doesn't exist, don't do anything\n    if (!this.tree[x] || !this.tree[y]) {\n      return;\n    }\n\n    // otherwise, delete it\n    delete this.tree[x][y];\n\n    // if the branch has no leaves, delete the branch, too\n    if (!Object.keys(this.tree[x]).length) {\n      delete this.tree[x]\n    }\n  }\n\n  get(x: number, y: number): T | undefined {\n    if (!this.has(x, y)) {\n      return undefined;\n    }\n\n    return this.tree[x][y];\n  }\n\n  has(x: number, y: number) {\n    const hasX = Object.prototype.hasOwnProperty.call(this.tree, \"\" + x);\n    if (!hasX) {\n      return false;\n    }\n    const hasY = Object.prototype.hasOwnProperty.call(this.tree[x], \"\" + y);\n    if (!hasY) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * \n   * @param x The x coordinate\n   * @param y The y coordinate\n   * @param callback Use this callback to set the new value. No-op if it returns undefined.\n   */\n  modify(x: number, y: number, callback: (val: T | undefined) => T | undefined) {\n    const oldVal = this.get(x, y);\n    const newVal = callback(oldVal);\n    if (newVal !== undefined) {\n      this.add(x, y, newVal)\n    }\n  }\n\n  toArray() {\n    type CoordinateArray = {x: number, y: number, val: T}[]\n    const arr: CoordinateArray = [];\n\n    Object.keys(this.tree).forEach((x) => {\n      Object.keys(this.tree[x]).forEach((y) => {\n        arr.push({x: +x, y: +y, val: this.tree[x][y]})\n      })\n    })\n    return arr;\n  }\n}","import { Player, PossibleMove, State } from \"../types\";\nimport CoordinateSet from \"../data/CoordinateSet\";\nimport { coords, fromTo } from \"../utils\";\n\nconst getPossibleMoves = (player: Player, state: State, occupiedCells: CoordinateSet<Player>): PossibleMove[] => {\n  // ADDRESSABLE CELLS STEP 1\n  // create a tree of all unique cells that are adjacent to any cell that this \n  // player owns, regardless of whether they're occupied.\n  const addressableTree = new CoordinateSet<boolean>();\n  player.cells.forEach(cell => {\n    fromTo(-1, 1, (x) => {\n      fromTo(-1, 1, (y) => {\n        addressableTree.add(cell.x + x, cell.y + y, true);\n      })\n    });\n  });\n\n  // ADDRESSABLE CELLS STEP 2\n  // second pass: player-occupied cells are not a possible move, so remove them\n  player.cells.forEach(cell => {\n    addressableTree.remove(cell.x, cell.y);\n  })\n\n  const addressableArr = addressableTree.toArray().filter(c => c.val === true);\n\n  // DECISIONS\n  // other-occupied cells can be attacked\n  const decisionTree = new CoordinateSet<PossibleMove>();\n  addressableArr.forEach(({x, y}) => {\n    if (occupiedCells.has(x, y)) {\n      const player = occupiedCells.get(x, y);\n\n      // handling weird edge case for Typescript's sake\n      if (!player) return;\n\n      decisionTree.add(x, y, {\n        type: \"ATTACK\",\n        targetCell: {\n          coords: coords(x,y),\n          owner: player\n        }\n      })\n    } else {\n      decisionTree.add(x, y, {\n        type: \"COLONIZE\",\n        targetCell: {\n          coords: coords(x,y)\n        }\n      })\n    }\n  });\n\n  // ADD POSSIBILITY OF PASSING THE TURN\n  const possibleMoves = decisionTree.toArray().map(c => c.val);\n  possibleMoves.push({\n    type: \"PASS\"\n  });\n\n  return possibleMoves;\n}\n\nexport default getPossibleMoves;","import { Player, State } from \"../types\";\nimport entropy from \"./entropy\";\nimport aggressor from \"../ai/aggressor\";\nimport getPossibleMoves from \"./getPossibleMoves\";\nimport CoordinateSet from \"../data/CoordinateSet\";\n\nconst play = (state: State) => {\n    // Make a 'map' of all occupied cells\n    const occupiedCells = new CoordinateSet<Player>();\n    state.players.forEach(player => {\n      player.cells.forEach(cell => {\n        occupiedCells.add(cell.x, cell.y, player);\n      })\n    })\n    \n  state.players.forEach(player => {\n    // get all possible moves\n    const possibleMoves = getPossibleMoves(player, state, occupiedCells);\n\n    // let the player pick a move\n    const move = player.ai({player, state, possibleMoves, occupiedCells});\n\n    // process the move\n    switch(move.type) {\n      case \"ATTACK\":\n        // player.cells.push(move.targetCell.coords);\n        move.targetCell.owner.cells = move.targetCell.owner.cells.filter(cell => cell.x !== move.targetCell.coords.x || cell.y !== move.targetCell.coords.y)\n        break;\n      case \"COLONIZE\":\n        player.cells.push(move.targetCell.coords);\n        break;\n      case \"PASS\":\n        break;\n      default:\n        break;\n    }\n  });\n  \n  entropy(state);\n}\n\nexport default play;","import { Camera, Coords, State } from \"../types\";\nimport { Component } from \"./component.type\";\nimport { SQUARE_BORDER } from \"../constants\";\nimport {  subtractCoords } from \"../utils\";\n\nconst drawRect = (ctx: CanvasRenderingContext2D, coords: Coords, color: string, camera: Camera) => {\n  const { x, y } = subtractCoords(coords, camera.origin)\n  ctx.strokeStyle = color;\n  ctx.fillStyle = color;\n  ctx.fillRect(x * camera.zoom, y * camera.zoom, (camera.zoom - SQUARE_BORDER), (camera.zoom - SQUARE_BORDER))\n}\n\nconst render: Component<{ state: State}> = ({state}) => {\n  const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    return;\n  }\n\n  // draw players\n  state.players.forEach(player => {\n    player.cells.forEach((coords) => {\n    \n      drawRect(ctx, coords, player.color, state.camera)\n    })\n  })\n}\n\nexport default render;","const resize = () => {\n  const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n\n  if(!canvas) {\n    return;\n  }\n\n  const width = window.innerWidth;\n  const height = window.innerHeight;\n\n  canvas.setAttribute(\"height\", \"\" + height )\n  canvas.setAttribute(\"width\", \"\" + width )\n}\n\nexport default resize;","import { Coords, State } from \"../types\";\nimport { addCoords, subtractCoords } from \"../utils\";\n\nconst dragHoc = (state: State, onDrag: () => void) => {\n  let lastCameraOrigin: Coords; // need this because browsers send bad coords sometimes\n  let isDrawing = false;\n  let clickOrigin: Coords;\n  let cameraOrigin: Coords;\n  const canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n\n  canvas.addEventListener('mousedown', function(evt) {\n    console.log('mousedown');\n    isDrawing = true;\n    clickOrigin = { x: evt.clientX, y: evt.clientY };\n    cameraOrigin = {...state.camera.origin}\n  })\n\n  canvas.addEventListener('mousemove', (evt) => {\n    if (!isDrawing) {\n      return;\n    }\n    console.log('mousemove');\n\n    const clickCoords: Coords = {\n      x: evt.clientX,\n      y: evt.clientY\n    }\n\n    const transposition: Coords = subtractCoords(clickCoords, clickOrigin);\n    lastCameraOrigin = state.camera.origin;\n    state.camera.origin = subtractCoords(cameraOrigin, transposition);\n\n    onDrag();\n  })\n\n  canvas.addEventListener('wheel', (evt) => {\n    console.log('wheel event triggered');\n    const event = evt as unknown as WheelEvent;\n    \n    evt.preventDefault();\n    // const SCALER = 5;\n    // const diff = Math.round(event.deltaY / SCALER);\n    const diff = event.deltaY === 0 \n      ? 0 \n      : event.deltaY > 0\n        ? 1\n        : -1;\n\n      \n    state.camera.zoom = Math.min(Math.max(state.camera.zoom + diff, 3), 7);\n    // state.camera.origin.x += diff / 2;\n    // state.camera.origin.y += diff / 2;\n\n\n    onDrag()\n  })\n\n  canvas.addEventListener('mouseup', () => {\n    console.log('mouseup');\n    isDrawing = false;\n    if (lastCameraOrigin) {\n      state.camera.origin = lastCameraOrigin;\n    }\n  })\n}\n\nexport default dragHoc;","import { Component } from \"./component.type\";\n\nconst clearCanvas: Component = ({ canvas }) => {\n  const ctx = canvas.getContext('2d');\n  ctx?.clearRect(0,0,canvas.width, canvas.height);\n}\n\nexport default clearCanvas;","import { Ai, PossibleMove } from \"../types\";\nimport { pick } from \"../utils\";\n\nconst aggressor: Ai = ({possibleMoves}): PossibleMove => {\n  // choose a move based on some logic, and return it\n  let tentativeMove: PossibleMove | undefined;\n  \n  const aggressiveMoves = possibleMoves.filter(pm => pm.type === \"ATTACK\");\n\n  // always pick aggressive moves\n  if (aggressiveMoves.length) {\n    tentativeMove = pick(aggressiveMoves);\n  } else {\n    tentativeMove = pick(possibleMoves)\n  }\n\n  if (!tentativeMove) {\n    tentativeMove = {\n      type: \"PASS\"\n    }\n  }\n\n  return tentativeMove;\n}\n\nexport default aggressor;","import { Ai, PossibleMove } from \"../types\";\nimport { pick } from \"../utils\";\n\nconst scaredycat: Ai = ({possibleMoves}): PossibleMove => {\n  // choose a move based on some logic, and return it\n  let tentativeMove: PossibleMove | undefined;\n  \n  tentativeMove = pick(possibleMoves.filter(pm => pm.type !== \"ATTACK\"));\n\n  if (!tentativeMove) {\n    tentativeMove = {\n      type: \"PASS\"\n    }\n  }\n\n  return tentativeMove;\n}\n\nexport default scaredycat;","import \"./reset.css\"\n\nimport { State } from \"./types\";\nimport { TICK_INTERVAL } from \"./constants\";\nimport play from \"./game/play\";\nimport render from \"./view/render\";\nimport resize from \"./listeners/resize\";\nimport { coords } from \"./utils\";\nimport dragHoc from \"./listeners/drag\";\nimport clearCanvas from \"./view/clearCanvas\";\nimport aggressor from \"./ai/aggressor\";\nimport scaredycat from \"./ai/scaredycat\";\n\nconst canvas: HTMLCanvasElement = document.getElementById('canvas') as HTMLCanvasElement;\n\nconst state: State = {\n  players: [\n    {\n      color: 'blue',\n      ai: scaredycat,\n      cells: [\n        coords(20, 20),\n      ],\n    },\n    {\n      color: 'red',\n      ai: aggressor,\n      cells: [\n        coords(15, 15),\n      ]\n    },\n    {\n      color: 'green',\n      ai: aggressor,\n      cells: [\n        coords(25, 25),\n      ]\n    }\n  ],\n  camera: {\n    origin: coords(-100,-100),\n    zoom: 5\n  }\n};\n\n// start game\nsetInterval(() => play(state), TICK_INTERVAL)\n\n// start animation\nconst doRender = () => {\n  clearCanvas({canvas});\n  render({state, canvas});\n  requestAnimationFrame(doRender);\n}\nrequestAnimationFrame(doRender)\n\n// listen for resizes\nwindow.addEventListener('resize', () => {\n  resize();\n  clearCanvas({canvas});\n})\nresize();\n\n// listener for dragging\ndragHoc(state, () => {\n  clearCanvas({canvas})\n});"],"names":["$491c08b17ce07690$export$5bf93b4680474bd","_x","_y","x","y","$491c08b17ce07690$export$ad19a5094122dc9b","a","b","$491c08b17ce07690$export$ed3047ae95eb9b2b","start","end","callback","i","$491c08b17ce07690$export$357523c63a2253b9","arr","length","index","$491c08b17ce07690$export$b141de964f0a90c1","undefined","max","Math","floor","random","$8d214408f19a9225$export$2e2bcd8739ae039","state","players","forEach","player","cells","numberOfCells","randomCellIndex","splice","$dbd879a4e1d22e51$export$2e2bcd8739ae039","add","x5","y5","val","this","tree","remove","x1","y1","Object","keys","get","x2","y2","has","x3","y3","prototype","hasOwnProperty","call","modify","x4","y4","newVal","toArray","push","$2a3b91f3c920d10b$export$2e2bcd8739ae039","player1","occupiedCells","addressableTree","cell","addressableArr","filter","c","decisionTree","type","targetCell","coords","owner","possibleMoves","map","$74a106239bce058c$export$2e2bcd8739ae039","move","ai","$92ba300e1b981fad$export$2e2bcd8739ae039","ctx","document","getElementById","getContext","color","camera","origin","strokeStyle","fillStyle","fillRect","zoom","$92ba300e1b981fad$var$drawRect","$15fd7dbc7d3d03f8$export$2e2bcd8739ae039","canvas","width","window","innerWidth","height","innerHeight","setAttribute","$d6299355fba89b70$export$2e2bcd8739ae039","onDrag","lastCameraOrigin","clickOrigin","cameraOrigin","isDrawing","addEventListener","evt","console","log","clientX","clientY","clickCoords","transposition","event","preventDefault","diff","deltaY","min","$0c3a382b741e81dd$export$2e2bcd8739ae039","clearRect","$2249b60c5077eea2$export$2e2bcd8739ae039","tentativeMove","aggressiveMoves","pm","$9ba632252bc9170e$export$2e2bcd8739ae039","$5ba171b4a505aeb2$var$canvas","$5ba171b4a505aeb2$var$state","setInterval","$5ba171b4a505aeb2$var$doRender","requestAnimationFrame"],"version":3,"file":"index.cc705d55.js.map"}